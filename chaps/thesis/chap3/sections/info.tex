% !TEX root = ../../main.tex

\section{Optimisations et performances}

Cette section s'intéresse aux aspects techniques de l'implémentation des schémas présentés dans la section~\ref{sec:3:scheme}. Il sera tout d'abord question de méthode de génération de code, utilisée uniquement dans le cadre de la méthode de Lawson, puis nous discuterons des performances et des choix d'implémentation effectués.

\subsection{Génération automatique de code}
\label{ssec:3:codegen}

La simulation d'un système à 7 variables, 6 variables à une dimension, et 1 variable à 4 dimensions, avec une méthode de type Lawson-Runge-Kutta (LRK) d'ordre élevé, nécessite de nombreuses lignes de code dont l'écriture peut s'avérer fastidieuse. Une part importante de l'analyse ayant été réalisée à l'aide de la bibliothèque de calcul symbolique \Python{} : \sympy, il a été décidé de poursuivre son utilisation pour aider à l'écriture du code de simulation. Dans un premier temps cet usage s'est limité à une aide à l'écriture en générant chacune des 7 expressions pour chaque variable, et ce à chaque étage de la méthode LRK (3 étages pour RK(3,3), jusqu'à 5 étages pour une méthode comme DP4(3)). Des outils de méta-programmation ont été utilisés pour obtenir une génération complète du code à partir d'un squelette de code et de l'écriture du schéma LRK que l'utilisateur souhaite utiliser.

Les expressions \sympy{} sont gérer comme des arbres syntaxiques dont les feuilles sont des nombres ou des symboles. Ces derniers vont servir à représenter des variables \CC, il est donc nécessaire dans un premier temps de s'assurer que la conversion de ces symboles en chaînes de caractères assure des noms de variables valide en \CC. En effet il est fréquent d'utiliser des symboles s'exportant facilement en \LaTeX{}, or un tel symbole n'est pas utilisable de la sorte comme nom de variable, par exemple $\Delta t$ sera s'exportera par défaut en chaîne de caractères en "\texttt{\textbackslash Delta\textbackslash\ t}". Les nœuds de l'arbre syntaxique sont des fonctions, il y a alors deux cas à distinguer, soit il s'agit d'une fonction dont la représentation en \Python{} est la même qu'en \CC, auquel cas aucune opération particulière n'est nécessaire, c'est le cas par exemple des opérations arithmétiques $+$, $-$, $\times$ et $\divisionsymbol$ qui sont représentées par les opérateurs binaires \texttt{+}, \texttt{-}, \texttt{*} et \texttt{/} en \Python{} et \CC{} ; soit il s'agit d'une fonction dont la représentation \Python{} et \CC{} diffère, auquel cas il est nécessaire de créer une fonction \sympy{} qui aura le même nom que la fonction \CC{} associée, et de substituer le nœud de l'arbre syntaxique par cette nouvelle fonction. La conversion en chaîne de caractère de l'arbre ainsi modifié sera une expression \CC{} valide. Il est possible d'améliorer l'expression \CC{} en faisant une évaluation numérique des nombre rationnels (et potentiellement aussi irrationnels) présents, pour limiter le nombre d'opérations dans l'expression finale. Ainsi l'expression \texttt{1/3} sera substituée par \texttt{0.333333333333333}, cela permet d'éviter des interprétation de fractions comme des divisions entières par le compilateur.

Pour chaque étage de la méthode LRK, il est ainsi possible d'obtenir une expression \CC{} valide par variable. L'étape supplémentaire pour assumer que l'on est un gros fainéant est d'utiliser un moteur de \emph{template} pour insérer ces expressions dans un squelette de code qui s'adapte automatiquement au nombre d'étages de la méthode LRK, en initialisant et allouant les variables temporaires nécessaires. Ce travail est effectuer par le moteur de \emph{template} Jinja2 qui est une bibliothèque \Python{} permettant d'ajouter des opérations logiques en plus d'une simple substitution de champs dans un squelette de code préexistant. Le squelette en pseudo-code d'un étage d'une méthode LRK est donné en exemple dans l'algorithme~\ref{alg:squeltte} dans la section~\ref{ssec:3:stage}.

\paragraph{Nota Bene :} La bibliothèque \sympy{} contient des fonctions permettant la génération de code en C ou Fortran, mais le fonctionnement de celles-ci s'adapte mal à une intégration dans une boucle d'un code déjà existant. De plus les fonctions ainsi générés ne fonctionnent pas avec un code contenant des \emph{template} \CC, pour changer éventuellement de type pour de possibles optimisations. Elles ne prennent en paramètre que des valeurs par copie ou par pointeur, ce qui limite leur usage avec des structures de données évoluées proposées par les librairies \CC. Il serait envisageable d'utiliser certains des mécanismes présents dans ces fonctions pour améliorer la génération de code proposé ci-dessus, en utilisant un parcours d'arbre syntaxique pour construire un \emph{Abstract Syntax Tree} (AST) permettant la génération dans n'importe quel langage d'une expression. \Josselin{Et derniers points, ces fonctions sont très mal documentées (je les ai découverte alors que je générais déjà les lignes de code pour le Lawson-RK(3,3) et que celui-ci tournait bien), et elles laissent des 1/2, 1/3 etc. qui peuvent valoir 0 selon les options de compilation ou les compilateurs.}

\subsection{Performances}

Nous souhaitons dans cette section présenter les choix techniques effecutés pour garantir la performance de l'implémentation des schémas détaillés dans la section~\ref{sec:3:scheme}, nous essayerons aussi de quantifier cette performance avec ou sans parallélisation.

\subsubsection{Structure de données}

Le choix a été fait, durant toute cette thèse, d'utiliser une méthode spectrale pour résoudre le transport en espace (direction $x$ ou $z$). Cela implique d'effectuer régulièrement des transformées de Fourier, ou des transformées inverses. Pour effectuer ces opérations efficacement il est nécessaire que cette mémoire soit contigüe en mémoire, cela indique qu'il s'agit du dernier indice dans les tableaux manipulés en \CC. Ainsi 

\subsubsection{Performance séquentielle}

\subsubsection{Performance parallélisée}


