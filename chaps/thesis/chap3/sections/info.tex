% !TEX root = ../../main.tex

\section{Optimisations et performances}

\subsection{Génération automatique de code}
\label{ssec:3:codegen}

La simulation d'un système à 7 variables, 6 variables à une dimension, et 1 variable à 4 dimensions, avec une méthode de type Lawson-Runge-Kutta (LRK) d'ordre élevé, nécessite de nombreuses lignes de code dont l'écriture peut s'avérer fastidieuse. Une part importante de l'analyse ayant été réalisée à l'aide de la bibliothèque de calcul symbolique \Python{} : \sympy, il a été décidé de poursuivre son utilisation pour aider à l'écriture du code de simulation. Dans un premier temps cet usage s'est limité à une aide à l'écriture en générant chacune des 7 expressions pour chaque variable, et ce à chaque étage de la méthode LRK (3 étages pour RK(3,3), jusqu'à 5 étages pour une méthode comme DP4(3)). Des outils de méta-programmation ont été utilisés pour obtenir une génération complète du code à partir d'un squelette de code et de l'écriture du schéma LRK que l'utilisateur souhaite utiliser.

Les expressions \sympy{} sont gérer comme des arbres syntaxiques dont les feuilles sont des nombres ou des symboles. Ces derniers vont servir à représenter des variables \CC, il est donc nécessaire dans un premier temps de s'assurer que la conversion de ces symboles en chaînes de caractères assure des noms de variables valide en \CC. En effet il est fréquent d'utiliser des symboles s'exportant facilement en \LaTeX{}, or un tel symbole n'est pas utilisable de la sorte comme nom de variable, par exemple $\Delta t$ sera s'exportera par défaut en chaîne de caractères en "\texttt{\textbackslash Delta\textbackslash\ t}". Les nœuds de l'arbre syntaxique sont des fonctions, il y a alors deux cas à distinguer, soit il s'agit d'une fonction dont la représentation en \Python{} est la même qu'en \CC, auquel cas aucune opération particulière n'est nécessaire, c'est le cas par exemple des opérations arithmétiques $+$, $-$, $\times$ et $\divisionsymbol$ qui sont représentées par les opérateurs binaires \texttt{+}, \texttt{-}, \texttt{*} et \texttt{/} en \Python{} et \CC{} ; soit il s'agit d'une fonction dont la représentation \Python{} et \CC{} diffère, auquel cas il est nécessaire de créer une fonction \sympy{} qui aura le même nom que la fonction \CC{} associée, et de substituer le nœud de l'arbre syntaxique par cette nouvelle fonction. La conversion en chaîne de caractère de l'arbre ainsi modifié sera une expression \CC{} valide. Il est possible d'améliorer l'expression \CC{} en faisant une évaluation numérique des nombre rationnels (et potentiellement aussi irrationnels) présents, pour limiter le nombre d'opérations dans l'expression finale. Ainsi l'expression \texttt{1/3} sera substituée par \texttt{0.333333333333333}, cela permet d'éviter des interprétation de fractions comme des divisions entières par le compilateur.

Pour chaque étage de la méthode LRK, il est ainsi possible d'obtenir une expression \CC{} valide par variable. L'étape supplémentaire pour assumer que l'on est un gros fainéant est d'utiliser un moteur de \emph{template} pour insérer ces expressions dans un squelette de code qui s'adapte automatiquement au nombre d'étages de la méthode LRK, en initialisant et allouant les variables temporaires nécessaires. Ce travail est effectuer par le moteur de \emph{template} Jinja2 qui est une bibliothèque \Python{} permettant d'ajouter des opérations logiques en plus d'une simple substitution de champs dans un squelette de code préexistant. Le squelette en pseudo-code d'un étage d'une méthode LRK est donné en exemple dans l'algorithme~\ref{alg:squeltte} dans la section~\ref{ssec:3:stage}.

\paragraph{Nota Bene :} La bibliothèque \sympy{} contient des fonctions permettant la génération de code en C ou Fortran, mais le fonctionnement de celles-ci s'adapte mal à une intégration dans une boucle d'un code déjà existant. De plus les fonctions ainsi générés ne fonctionnent pas avec un code contenant des \emph{template} \CC, pour changer éventuellement de type pour de possibles optimisations. Elles ne prennent en paramètre que des valeurs par copie ou par pointeur, ce qui limite leur usage avec des structures de données évoluées proposées par les librairies \CC. Il serait envisageable d'utiliser certains des mécanismes présents dans ces fonctions pour améliorer la génération de code proposé ci-dessus, en utilisant un parcours d'arbre syntaxique pour construire un \emph{Abstract Syntax Tree} (AST) permettant la génération dans n'importe quel langage d'une expression. \Josselin{Et derniers points, ces fonctions sont très mal documentées (je les ai découverte alors que je générais déjà les lignes de code pour le Lawson-RK(3,3) et que celui-ci tournait bien), et elles laissent des 1/2, 1/3 etc. qui peuvent valoir 0 selon les options de compilation ou les compilateurs.}

\subsection{Parallélisation}

\Josselin{Je ne sais pas trop quoi dire là dedans. Pour le moment la parallélisation n'est pas faite à cause de FFTW. J'ai trouvé une exemple de code pour indiquer comment utiliser FFTW avec OpenMP, mais il n'y a rien de très passionant à dire ici (à mon sens). Il faudra voir avec le gain en temps de calcul.}

\Josselin{Autre problème de cette section c'est le code Taylor/Padé. Ceux-ci tournent correctement sur ma machine mais pas sur le serveur de calcul, je présume que la différence est surtout la version de GCC. Pierre m'a indiqué qu'il n'était pas prévu de mettre à jour GCC sur la machine de calcul actuelle car les dépendances ne peuvent être gérées sur la version de Fedora qui y tourne, et il ne sait pas quand le nouveau serveur sera opérationel. Or (je n'ai jamais testé mais c'est ce qu'on lit un peu partout) MacOS gère pas très très bien OpenMP, il est donc (possiblement) compliqué de faire ces tests sur ma machine.}

\subsection{Performances}


